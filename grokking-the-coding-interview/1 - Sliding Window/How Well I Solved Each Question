1 - Maximum Sum Subarray of Size K (good understanding)
- Created solution that had same time complexity but worse space complexity
- Saw model solution, understood it immediately, and changed og solution to follow it without looking at it 


2 - Smallest Subarray with a given sum (good understanding)
- Knew what the correct algorithm / solution was. Just couldn't figure out how to represent it as code
- Saw model solution, took some time to understand how code was working but went through an example and understood eventually, changed og solution to follow it without looking at it 

3 - Longest Substring with K Distinct Characters (good understanding)
- Had a sense of the correct also but didn't have all the details right. couldn't figure out how to represent it as code
- Saw model solution, took a LONGGGG (i mean couple hours and multiple tries) time to understand how code was working but went through an example and understood eventually, changed og solution to follow it without looking at it 

4 - Fruits into Baskets (very good understanding)
- it was the same question as #3 so knew the correct algorithm + figured out how to represent it as code
- my solution didn't need any changing as it was the same os model solution

5 - No-repeat Substring (very good understanding)
- same as #3 and #4 so knew correct also + knew how to represent as code
- my solution was however different from model solution. Instead of object recording counts of char occurrences in our window / substring - which I did - model solution recorded last index of each character in our window / substring -> having said that the time and space complexities are the same so in terms of performance both would be considered equally good answers. There is a better solution - in terms of space complexity - that uses a 26 length array but I didn't bother trying to implement it. Or actually... I did and it worked.


*Originally was going to solve 6 -> tried to and by solving it like a computer would aka. step by step - I thought I saw an algorithm to represent that process. Having said that I determined figuring out how to write it out (even worse turn it into code) would be a bit of a hassle. -> I also looked at the model solution and it was using some unintuitive logic so I decided I'd had enough of Sliding Window. I'd already used it to solve multiple questions to the point where I had a decent grasp of how to use it to solve certain problems. If I ever want to go deeper into it I can later. For now let's focus on getting decent exposure to all the patterns. After all, it's not like I've got unlimited time. Better I get down the breadth so I can at least have a chance at solving a question as opposed to being completely in the dark because i went deep into one pattern and didn't have time for the others. 