{\rtf1\ansi\ansicpg1252\cocoartf2513
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fswiss\fcharset0 Helvetica-Bold;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 1. Sliding Window\
- by using a window that both expands and shrinks as it looks at the input, we can find solutions to problems dealing with an array (or Linked List) that ask us to 
\f1\b find or calculate something among all the contiguous subarrays (or sublists) of a given size
\f0\b0 \'85. that are more efficient than brute force solutions.\
- i.e. \'93Given an array, find the average of all contiguous subarrays of size \'91K\'92 in it.\'94 \
[1, 3, 2, 6, -1, 4, 1, 8, 2], K=5 \
	- Brute Force way would be to calculate first 5 aka. 1 + 3 + 2 + 5 - 1 / 5 -> and then next 5 aka. 3 + 2 + 5 - 1 + 4  / 5 and so on. -> notice the inefficiency where we\'92re going back to values that we already looked at (i.e. 3, 2, 5, 1 b/w 1st subarray and 2nd subarray). Is there a way to avoid this overlap?\
	- Sliding Window avoid overlap because as it expands - aka. as we add the next element to the end of the window - and as it shrinks - aka. as we remove the element at the start of the window\'85 we\'92ll only go through each element once for each process aka. we never add an element that we\'92ve already added before - to the window - again and we never remove an element that we\'92ve already removed - from the window - again \
\
\
2. Two Pointers\
- thinking of creative ways to use two pointers can let you efficiently solve problems where
\f1\b  you have to find a set of elements in a sorted array (or sorted linked list) that fulfill certain constraints
\f0\b0 \
i.e.\'94 Given an array of sorted numbers and a target sum, find a pair in the array whose sum is equal to the given target.\'94\
	- Brute force / dumb way of using two pointers would be to start off from beginning of the array and for each element in the array (first pointer) check it\'92s sum with all the following elements (2nd pointer) -> problem with that is it\'92s O(n^2) time and that\'92s a long time. So what\'92s a better way to use two pointers?\
	- (Creative) Two Pointers -> leverage the fact that the array is sorted by having a pointer at the start and another at the beginning. Calculate the sum. Since you know the start is the smallest and the end is the biggest, if the sum is < than the target sum move the first pointer / pointer at the start forward by 1 index. If the sum is > than the target sum move the second pointer / pointer at the end back by 1 index. You keep doing this until you get your target sum and if you don\'92t get it well then you don\'92t have values that fulfill the desired condition. Since max you\'92ll only look at all the elements in the array once time complexity is O(n) which is much better.\
}